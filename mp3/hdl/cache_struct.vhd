-- VHDL Entity ece411.cache.symbol
--
-- Created:
--          by - freed2.ews (gelib-057-15.ews.illinois.edu)
--          at - 23:43:17 04/03/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY cache IS
   PORT( 
      ADDRESS     : IN     LC3b_word;
      DATAOUT     : IN     LC3b_word;
      MREAD_L     : IN     std_logic;
      MWRITEH_L   : IN     std_logic;
      MWRITEL_L   : IN     std_logic;
      PMRESP_H    : IN     std_logic;
      RESET_L     : IN     std_logic;
      c_write     : IN     std_logic;
      clk         : IN     std_logic;
      cresp_out   : IN     std_logic;
      cwaitout    : IN     std_logic;
      ddata       : IN     std_logic;
      pmdatain    : IN     LC3B_OWORD;
      pmreadstate : IN     std_logic;
      writeback   : IN     std_logic;
      DATAIN      : OUT    LC3b_word;
      MRESP_H     : OUT    std_logic;
      MemReadCall : OUT    std_logic;
      hitmissout  : OUT    std_logic;
      needWB_H    : OUT    std_logic;
      pmaddress   : OUT    LC3B_WORD;
      pmdataout   : OUT    LC3B_OWORD;
      write       : OUT    std_logic
   );

-- Declarations

END cache ;

--
-- VHDL Architecture ece411.cache.struct
--
-- Created:
--          by - freed2.ews (gelib-057-15.ews.illinois.edu)
--          at - 23:43:18 04/03/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

LIBRARY cachelib;

ARCHITECTURE struct OF cache IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL CacheWriteGo   : std_logic;
   SIGNAL Cache_Access   : std_logic;
   SIGNAL Cacheout       : LC3B_OWORD;
   SIGNAL DataOut1       : std_logic;
   SIGNAL DataOut2       : std_logic;
   SIGNAL F2             : std_logic;
   SIGNAL ONE_OUT        : std_logic;
   SIGNAL Out4           : std_logic;
   SIGNAL PMAddressSel   : std_logic;
   SIGNAL PMRESP_L       : std_logic;
   SIGNAL ReadInverse    : std_logic;
   SIGNAL ReadyStore     : std_logic;
   SIGNAL StoreAddrOut   : LC3b_word;
   SIGNAL Tagarray0out   : LC3B_C_TAG;
   SIGNAL Tagarray1out   : LC3B_C_TAG;
   SIGNAL Valid1Out      : std_logic;
   SIGNAL Valid2Out      : std_logic;
   SIGNAL Way0ADDR       : lc3b_word;
   SIGNAL Way0Compout    : std_logic;
   SIGNAL Way0Out        : LC3B_OWORD;
   SIGNAL Way1ADDR       : lc3b_word;
   SIGNAL Way1CompOut    : std_logic;
   SIGNAL Way1Out        : LC3B_OWORD;
   SIGNAL Word0MuxSelOut : LC3B_WORD;
   SIGNAL Word1MuxSelOut : LC3B_WORD;
   SIGNAL alldatain      : LC3B_OWORD;
   SIGNAL bitout         : std_logic;
   SIGNAL bitout1        : std_logic;
   SIGNAL din            : std_logic;
   SIGNAL dirty          : std_logic;
   SIGNAL dout           : std_logic;
   SIGNAL dout1          : std_logic;
   SIGNAL dout2          : std_logic;
   SIGNAL dout3          : std_logic;
   SIGNAL hitter         : std_logic;
   SIGNAL index          : LC3B_C_INDEX;
   SIGNAL lruout         : std_logic;
   SIGNAL lruoutinv      : std_logic;
   SIGNAL miss           : std_logic;
   SIGNAL misser         : std_logic;
   SIGNAL offset         : LC3B_C_OFFSET;
   SIGNAL tag            : LC3B_C_TAG;
   SIGNAL toStoreOut     : lc3b_oword;
   SIGNAL updateLRU      : std_logic;
   SIGNAL validcheck0    : std_logic;
   SIGNAL validcheck1    : std_logic;
   SIGNAL way0miss       : std_logic;
   SIGNAL way0write      : std_logic;
   SIGNAL way1miss       : std_logic;
   SIGNAL way1write      : std_logic;

   -- Implicit buffer signal declarations
   SIGNAL hitmissout_internal : std_logic;
   SIGNAL needWB_H_internal   : std_logic;
   SIGNAL write_internal      : std_logic;


   -- Component Declarations
   COMPONENT AND2
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      F : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT AND3Bit
   PORT (
      A      : IN     std_logic ;
      B      : IN     std_logic ;
      C      : IN     std_logic ;
      Output : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT AND4Bit
   PORT (
      A    : IN     std_logic ;
      B    : IN     std_logic ;
      C    : IN     std_logic ;
      D    : IN     std_logic ;
      Out4 : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT CACHE_JOINER
   PORT (
      Cacheout   : IN     LC3B_OWORD ;
      OFFSET     : IN     LC3B_C_OFFSET ;
      StoreData  : IN     LC3B_WORD ;
      WRITEH_L   : IN     std_logic ;
      WRITEL_L   : IN     std_logic ;
      toStoreOut : OUT    lc3b_oword 
   );
   END COMPONENT;
   COMPONENT Compare9
   PORT (
      InA   : IN     LC3B_C_TAG ;
      InB   : IN     LC3B_C_TAG ;
      Equal : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT DataArray
   PORT (
      Reset_L   : IN     std_logic ;
      DataWrite : IN     std_logic ;
      Index     : IN     LC3B_C_INDEX ;
      DataIn    : IN     LC3B_OWORD ;
      DataOut   : OUT    LC3B_OWORD 
   );
   END COMPONENT;
   COMPONENT OR2
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      F : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT OWordMux2
   PORT (
      A        : IN     LC3B_OWORD ;
      B        : IN     LC3B_OWORD ;
      SEL      : IN     std_logic ;
      OWORDOUT : OUT    LC3B_OWORD 
   );
   END COMPONENT;
   COMPONENT SingleBitArray
   PORT (
      Reset_L   : IN     std_logic ;
      DataWrite : IN     std_logic ;
      Index     : IN     LC3B_C_INDEX ;
      DataIn    : IN     std_logic ;
      DataOut   : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT TagArray
   PORT (
      Reset_L   : IN     std_logic ;
      DataWrite : IN     std_logic ;
      Index     : IN     LC3B_C_INDEX ;
      DataIn    : IN     LC3B_C_TAG ;
      DataOut   : OUT    LC3B_C_TAG 
   );
   END COMPONENT;
   COMPONENT WordMux2
   PORT (
      A   : IN     LC3b_word ;
      B   : IN     LC3b_word ;
      Sel : IN     std_logic ;
      F   : OUT    LC3b_word 
   );
   END COMPONENT;
   COMPONENT WordMux2Sel2
   PORT (
      A    : IN     LC3b_word ;
      B    : IN     LC3b_word ;
      InA  : IN     std_logic ;
      out2 : OUT    LC3b_word 
   );
   END COMPONENT;
   COMPONENT WordMux8
   PORT (
      A000    : IN     LC3B_WORD ;
      B001    : IN     LC3B_WORD ;
      C010    : IN     LC3B_WORD ;
      D011    : IN     LC3B_WORD ;
      E100    : IN     LC3B_WORD ;
      F101    : IN     LC3B_WORD ;
      G110    : IN     LC3B_WORD ;
      H111    : IN     LC3B_WORD ;
      SEL8    : IN     LC3B_8MUX_SEL ;
      MUX8OUT : OUT    LC3B_WORD 
   );
   END COMPONENT;
   COMPONENT bitmux2
   PORT (
      A      : IN     std_logic ;
      B      : IN     std_logic ;
      Sel    : IN     std_logic ;
      bitout : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT ADDR_SPLIT1
   PORT (
      index   : OUT    LC3B_C_INDEX ;
      offset  : OUT    LC3B_C_OFFSET ;
      ADDRESS : IN     LC3b_word ;
      tag     : OUT    LC3B_C_TAG 
   );
   END COMPONENT;
   COMPONENT MemStoreAddressCalc1
   PORT (
      Way0ADDR     : OUT    lc3b_word ;
      Way1ADDR     : OUT    lc3b_word ;
      index        : IN     LC3B_C_INDEX ;
      Tagarray0out : IN     LC3B_C_TAG ;
      Tagarray1out : IN     LC3B_C_TAG 
   );
   END COMPONENT;
   COMPONENT STD_ONE2
   PORT (
      ONE_OUT : OUT    std_logic 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : ADDR_SPLIT1 USE ENTITY ece411.ADDR_SPLIT1;
   FOR ALL : AND2 USE ENTITY cachelib.AND2;
   FOR ALL : AND3Bit USE ENTITY cachelib.AND3Bit;
   FOR ALL : AND4Bit USE ENTITY cachelib.AND4Bit;
   FOR ALL : CACHE_JOINER USE ENTITY cachelib.CACHE_JOINER;
   FOR ALL : Compare9 USE ENTITY cachelib.Compare9;
   FOR ALL : DataArray USE ENTITY cachelib.DataArray;
   FOR ALL : MemStoreAddressCalc1 USE ENTITY ece411.MemStoreAddressCalc1;
   FOR ALL : OR2 USE ENTITY cachelib.OR2;
   FOR ALL : OWordMux2 USE ENTITY cachelib.OWordMux2;
   FOR ALL : STD_ONE2 USE ENTITY ece411.STD_ONE2;
   FOR ALL : SingleBitArray USE ENTITY cachelib.SingleBitArray;
   FOR ALL : TagArray USE ENTITY cachelib.TagArray;
   FOR ALL : WordMux2 USE ENTITY cachelib.WordMux2;
   FOR ALL : WordMux2Sel2 USE ENTITY cachelib.WordMux2Sel2;
   FOR ALL : WordMux8 USE ENTITY cachelib.WordMux8;
   FOR ALL : bitmux2 USE ENTITY cachelib.bitmux2;
   -- pragma synthesis_on


BEGIN
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 2 eb2
   MRESP_H <= hitter;
                                         


   -- ModuleWare code(v1.9) for instance 'PMRESPVERSE' of 'inv'
   PMRESP_L <= NOT(PMRESP_H);

   -- ModuleWare code(v1.9) for instance 'U_5' of 'inv'
   dout1 <= NOT(dirty);

   -- ModuleWare code(v1.9) for instance 'U_7' of 'inv'
   ReadInverse <= NOT(MREAD_L);

   -- ModuleWare code(v1.9) for instance 'U_8' of 'inv'
   miss <= NOT(hitmissout_internal);

   -- ModuleWare code(v1.9) for instance 'U_11' of 'inv'
   dout3 <= NOT(clk);

   -- ModuleWare code(v1.9) for instance 'U_20' of 'inv'
   way0miss <= NOT(validcheck0);

   -- ModuleWare code(v1.9) for instance 'U_21' of 'inv'
   way1miss <= NOT(validcheck1);

   -- ModuleWare code(v1.9) for instance 'U_34' of 'inv'
   Cache_Access <= NOT(din);

   -- ModuleWare code(v1.9) for instance 'lruinv' of 'inv'
   lruoutinv <= NOT(lruout);

   -- ModuleWare code(v1.9) for instance 'lruinv1' of 'inv'
   dout <= NOT(MWRITEH_L);

   -- ModuleWare code(v1.9) for instance 'lruinv2' of 'inv'
   dout2 <= NOT(MWRITEL_L);

   -- Instance port mappings.
   DirtyMiss : AND2
      PORT MAP (
         A => dirty,
         B => misser,
         F => needWB_H_internal
      );
   DirtyMiss1 : AND2
      PORT MAP (
         A => dout1,
         B => misser,
         F => MemReadCall
      );
   U_1 : AND2
      PORT MAP (
         A => Valid1Out,
         B => Way0Compout,
         F => validcheck0
      );
   U_3 : AND2
      PORT MAP (
         A => Valid2Out,
         B => Way1CompOut,
         F => validcheck1
      );
   U_4 : AND2
      PORT MAP (
         A => CacheWriteGo,
         B => bitout,
         F => way1write
      );
   U_19 : AND2
      PORT MAP (
         A => CacheWriteGo,
         B => bitout1,
         F => way0write
      );
   U_36 : AND2
      PORT MAP (
         A => miss,
         B => Cache_Access,
         F => misser
      );
   U_37 : AND2
      PORT MAP (
         A => needWB_H_internal,
         B => PMRESP_L,
         F => F2
      );
   U_40 : AND2
      PORT MAP (
         A => pmreadstate,
         B => PMRESP_H,
         F => ReadyStore
      );
   U_18 : AND3Bit
      PORT MAP (
         A      => MREAD_L,
         B      => MWRITEH_L,
         C      => MWRITEL_L,
         Output => din
      );
   U_35 : AND3Bit
      PORT MAP (
         A      => Cache_Access,
         B      => cwaitout,
         C      => hitmissout_internal,
         Output => hitter
      );
   U_9 : AND4Bit
      PORT MAP (
         A    => cwaitout,
         B    => Cache_Access,
         C    => hitmissout_internal,
         D    => dout3,
         Out4 => updateLRU
      );
   U_41 : AND4Bit
      PORT MAP (
         A    => cwaitout,
         B    => write_internal,
         C    => hitmissout_internal,
         D    => hitmissout_internal,
         Out4 => Out4
      );
   Line_Adjust : CACHE_JOINER
      PORT MAP (
         Cacheout   => Cacheout,
         OFFSET     => offset,
         StoreData  => DATAOUT,
         WRITEH_L   => MWRITEH_L,
         WRITEL_L   => MWRITEL_L,
         toStoreOut => toStoreOut
      );
   TagCompWay0 : Compare9
      PORT MAP (
         InA   => Tagarray0out,
         InB   => tag,
         Equal => Way0Compout
      );
   TagCompWay1 : Compare9
      PORT MAP (
         InA   => Tagarray1out,
         InB   => tag,
         Equal => Way1CompOut
      );
   Way00 : DataArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => way0write,
         Index     => index,
         DataIn    => alldatain,
         DataOut   => Way0Out
      );
   Way01 : DataArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => way1write,
         Index     => index,
         DataIn    => alldatain,
         DataOut   => Way1Out
      );
   U_39 : OR2
      PORT MAP (
         A => F2,
         B => writeback,
         F => PMAddressSel
      );
   U_42 : OR2
      PORT MAP (
         A => ReadyStore,
         B => Out4,
         F => CacheWriteGo
      );
   hitmiss : OR2
      PORT MAP (
         A => validcheck0,
         B => validcheck1,
         F => hitmissout_internal
      );
   mem_write_check : OR2
      PORT MAP (
         A => dout,
         B => dout2,
         F => write_internal
      );
   CacheDataInMux : OWordMux2
      PORT MAP (
         A        => pmdatain,
         B        => toStoreOut,
         SEL      => cwaitout,
         OWORDOUT => alldatain
      );
   U_6 : OWordMux2
      PORT MAP (
         A        => Way0Out,
         B        => Way1Out,
         SEL      => lruout,
         OWORDOUT => pmdataout
      );
   WayOutSel : OWordMux2
      PORT MAP (
         A        => Way0Out,
         B        => Way1Out,
         SEL      => validcheck1,
         OWORDOUT => Cacheout
      );
   DirtyWay0 : SingleBitArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => way0write,
         Index     => index,
         DataIn    => cwaitout,
         DataOut   => DataOut2
      );
   DirtyWay1 : SingleBitArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => way1write,
         Index     => index,
         DataIn    => cwaitout,
         DataOut   => DataOut1
      );
   LRU : SingleBitArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => updateLRU,
         Index     => index,
         DataIn    => validcheck0,
         DataOut   => lruout
      );
   ValidWay0 : SingleBitArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => way0write,
         Index     => index,
         DataIn    => ONE_OUT,
         DataOut   => Valid1Out
      );
   ValidWay1 : SingleBitArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => way1write,
         Index     => index,
         DataIn    => ONE_OUT,
         DataOut   => Valid2Out
      );
   Way0Tags : TagArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => way0write,
         Index     => index,
         DataIn    => tag,
         DataOut   => Tagarray0out
      );
   Way1Tags : TagArray
      PORT MAP (
         Reset_L   => RESET_L,
         DataWrite => way1write,
         Index     => index,
         DataIn    => tag,
         DataOut   => Tagarray1out
      );
   StoreAddrMux : WordMux2
      PORT MAP (
         A   => Way0ADDR,
         B   => Way1ADDR,
         Sel => lruout,
         F   => StoreAddrOut
      );
   StoreAddrMux1 : WordMux2
      PORT MAP (
         A   => ADDRESS,
         B   => StoreAddrOut,
         Sel => PMAddressSel,
         F   => pmaddress
      );
   WayMux : WordMux2Sel2
      PORT MAP (
         A    => Word0MuxSelOut,
         B    => Word1MuxSelOut,
         InA  => validcheck1,
         out2 => DATAIN
      );
   Way0WordMux : WordMux8
      PORT MAP (
         A000    => Way0Out(15 downto 0),
         B001    => Way0Out(31 downto 16),
         C010    => Way0Out(47 downto 32),
         D011    => Way0Out(63 downto 48),
         E100    => Way0Out(79 downto 64),
         F101    => Way0Out(95 downto 80),
         G110    => Way0Out(111 downto 96),
         H111    => Way0Out(127 downto 112),
         SEL8    => offset,
         MUX8OUT => Word0MuxSelOut
      );
   Way1WordMux : WordMux8
      PORT MAP (
         A000    => Way1Out(15 downto 0),
         B001    => Way1Out(31 downto 16),
         C010    => Way1Out(47 downto 32),
         D011    => Way1Out(63 downto 48),
         E100    => Way1Out(79 downto 64),
         F101    => Way1Out(95 downto 80),
         G110    => Way1Out(111 downto 96),
         H111    => Way1Out(127 downto 112),
         SEL8    => offset,
         MUX8OUT => Word1MuxSelOut
      );
   U_2 : bitmux2
      PORT MAP (
         A      => lruout,
         B      => validcheck1,
         Sel    => cwaitout,
         bitout => bitout
      );
   U_10 : bitmux2
      PORT MAP (
         A      => DataOut2,
         B      => DataOut1,
         Sel    => lruout,
         bitout => dirty
      );
   U_15 : bitmux2
      PORT MAP (
         A      => lruoutinv,
         B      => validcheck0,
         Sel    => cwaitout,
         bitout => bitout1
      );
   Addr_splitter : ADDR_SPLIT1
      PORT MAP (
         index   => index,
         offset  => offset,
         ADDRESS => ADDRESS,
         tag     => tag
      );
   StoreAddrCalc : MemStoreAddressCalc1
      PORT MAP (
         Way0ADDR     => Way0ADDR,
         Way1ADDR     => Way1ADDR,
         index        => index,
         Tagarray0out => Tagarray0out,
         Tagarray1out => Tagarray1out
      );
   U_0 : STD_ONE2
      PORT MAP (
         ONE_OUT => ONE_OUT
      );

   -- Implicit buffered output assignments
   hitmissout <= hitmissout_internal;
   needWB_H   <= needWB_H_internal;
   write      <= write_internal;

END struct;
